/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/PathFinding.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/heap */ \"./node_modules/heap/lib/heap.js\");\n\n\n//# sourceURL=webpack:///./node_modules/heap/index.js?");

/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if ( true && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/heap/lib/heap.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/PathFinding.js":
/*!****************************!*\
  !*** ./src/PathFinding.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var pathfinding = {\n  'Heap': __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\"),\n  'Node': __webpack_require__(/*! ./core/Node */ \"./src/core/Node.js\"),\n  'Grid': __webpack_require__(/*! ./core/Grid */ \"./src/core/Grid.js\"),\n  'Util': __webpack_require__(/*! ./core/Util */ \"./src/core/Util.js\"),\n  'DiagonalMovement': __webpack_require__(/*! ./core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\"),\n  'Heuristic': __webpack_require__(/*! ./core/Heuristic */ \"./src/core/Heuristic.js\"),\n  'AStarFinder': __webpack_require__(/*! ./finders/AStarFinder */ \"./src/finders/AStarFinder.js\"),\n  'BestFirstFinder': __webpack_require__(/*! ./finders/BestFirstFinder */ \"./src/finders/BestFirstFinder.js\"),\n  'BreadthFirstFinder': __webpack_require__(/*! ./finders/BreadthFirstFinder */ \"./src/finders/BreadthFirstFinder.js\"),\n  'DijkstraFinder': __webpack_require__(/*! ./finders/DijkstraFinder */ \"./src/finders/DijkstraFinder.js\"),\n  'BiAStarFinder': __webpack_require__(/*! ./finders/BiAStarFinder */ \"./src/finders/BiAStarFinder.js\"),\n  'BiBestFirstFinder': __webpack_require__(/*! ./finders/BiBestFirstFinder */ \"./src/finders/BiBestFirstFinder.js\"),\n  'BiBreadthFirstFinder': __webpack_require__(/*! ./finders/BiBreadthFirstFinder */ \"./src/finders/BiBreadthFirstFinder.js\"),\n  'BiDijkstraFinder': __webpack_require__(/*! ./finders/BiDijkstraFinder */ \"./src/finders/BiDijkstraFinder.js\"),\n  'IDAStarFinder': __webpack_require__(/*! ./finders/IDAStarFinder */ \"./src/finders/IDAStarFinder.js\"),\n  'JumpPointFinder': __webpack_require__(/*! ./finders/JumpPointFinder */ \"./src/finders/JumpPointFinder.js\")\n};\nwindow.PF = pathfinding;\n\n//# sourceURL=webpack:///./src/PathFinding.js?");

/***/ }),

/***/ "./src/core/DiagonalMovement.js":
/*!**************************************!*\
  !*** ./src/core/DiagonalMovement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var DiagonalMovement = {\n  Always: 1,\n  Never: 2,\n  IfAtMostOneObstacle: 3,\n  OnlyWhenNoObstacles: 4\n};\nmodule.exports = DiagonalMovement;\n\n//# sourceURL=webpack:///./src/core/DiagonalMovement.js?");

/***/ }),

/***/ "./src/core/Grid.js":
/*!**************************!*\
  !*** ./src/core/Grid.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Node = __webpack_require__(/*! ./Node */ \"./src/core/Node.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ./DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\n\n\nfunction Grid(width_or_matrix, height, matrix) {\n  var width;\n\n  if (_typeof(width_or_matrix) !== 'object') {\n    width = width_or_matrix;\n  } else {\n    height = width_or_matrix.length;\n    width = width_or_matrix[0].length;\n    matrix = width_or_matrix;\n  }\n  /**\r\n   * The number of columns of the grid.\r\n   * @type number\r\n   */\n\n\n  this.width = width;\n  /**\r\n   * The number of rows of the grid.\r\n   * @type number\r\n   */\n\n  this.height = height;\n  /**\r\n   * A 2D array of nodes.\r\n   */\n\n  this.nodes = this._buildNodes(width, height, matrix);\n}\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\n\n\nGrid.prototype._buildNodes = function (width, height, matrix) {\n  var i,\n      j,\n      nodes = new Array(height);\n\n  for (i = 0; i < height; ++i) {\n    nodes[i] = new Array(width);\n\n    for (j = 0; j < width; ++j) {\n      nodes[i][j] = new Node(j, i);\n    }\n  }\n\n  if (matrix === undefined) {\n    return nodes;\n  }\n\n  if (matrix.length !== height || matrix[0].length !== width) {\n    throw new Error('Matrix size does not fit');\n  }\n\n  for (i = 0; i < height; ++i) {\n    for (j = 0; j < width; ++j) {\n      if (matrix[i][j]) {\n        // 0, false, null will be walkable\n        // while others will be un-walkable\n        nodes[i][j].walkable = false;\n      }\n    }\n  }\n\n  return nodes;\n};\n\nGrid.prototype.getNodeAt = function (x, y) {\n  return this.nodes[y][x];\n};\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\n\n\nGrid.prototype.isWalkableAt = function (x, y) {\n  return this.isInside(x, y) && this.nodes[y][x].walkable;\n};\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\n\n\nGrid.prototype.isInside = function (x, y) {\n  return x >= 0 && x < this.width && y >= 0 && y < this.height;\n};\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\n\n\nGrid.prototype.setWalkableAt = function (x, y, walkable) {\n  this.nodes[y][x].walkable = walkable;\n};\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\n\n\nGrid.prototype.getNeighbors = function (node, diagonalMovement) {\n  var x = node.x,\n      y = node.y,\n      neighbors = [],\n      s0 = false,\n      d0 = false,\n      s1 = false,\n      d1 = false,\n      s2 = false,\n      d2 = false,\n      s3 = false,\n      d3 = false,\n      nodes = this.nodes; // ↑\n\n  if (this.isWalkableAt(x, y - 1)) {\n    neighbors.push(nodes[y - 1][x]);\n    s0 = true;\n  } // →\n\n\n  if (this.isWalkableAt(x + 1, y)) {\n    neighbors.push(nodes[y][x + 1]);\n    s1 = true;\n  } // ↓\n\n\n  if (this.isWalkableAt(x, y + 1)) {\n    neighbors.push(nodes[y + 1][x]);\n    s2 = true;\n  } // ←\n\n\n  if (this.isWalkableAt(x - 1, y)) {\n    neighbors.push(nodes[y][x - 1]);\n    s3 = true;\n  }\n\n  if (diagonalMovement === DiagonalMovement.Never) {\n    return neighbors;\n  }\n\n  if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n    d0 = s3 && s0;\n    d1 = s0 && s1;\n    d2 = s1 && s2;\n    d3 = s2 && s3;\n  } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\n    d0 = s3 || s0;\n    d1 = s0 || s1;\n    d2 = s1 || s2;\n    d3 = s2 || s3;\n  } else if (diagonalMovement === DiagonalMovement.Always) {\n    d0 = true;\n    d1 = true;\n    d2 = true;\n    d3 = true;\n  } else {\n    throw new Error('Incorrect value of diagonalMovement');\n  } // ↖\n\n\n  if (d0 && this.isWalkableAt(x - 1, y - 1)) {\n    neighbors.push(nodes[y - 1][x - 1]);\n  } // ↗\n\n\n  if (d1 && this.isWalkableAt(x + 1, y - 1)) {\n    neighbors.push(nodes[y - 1][x + 1]);\n  } // ↘\n\n\n  if (d2 && this.isWalkableAt(x + 1, y + 1)) {\n    neighbors.push(nodes[y + 1][x + 1]);\n  } // ↙\n\n\n  if (d3 && this.isWalkableAt(x - 1, y + 1)) {\n    neighbors.push(nodes[y + 1][x - 1]);\n  }\n\n  return neighbors;\n};\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\n\n\nGrid.prototype.clone = function () {\n  var i,\n      j,\n      width = this.width,\n      height = this.height,\n      thisNodes = this.nodes,\n      newGrid = new Grid(width, height),\n      newNodes = new Array(height);\n\n  for (i = 0; i < height; ++i) {\n    newNodes[i] = new Array(width);\n\n    for (j = 0; j < width; ++j) {\n      newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\n    }\n  }\n\n  newGrid.nodes = newNodes;\n  return newGrid;\n};\n\nmodule.exports = Grid;\n\n//# sourceURL=webpack:///./src/core/Grid.js?");

/***/ }),

/***/ "./src/core/Heuristic.js":
/*!*******************************!*\
  !*** ./src/core/Heuristic.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\nmodule.exports = {\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\n  manhattan: function manhattan(dx, dy) {\n    return dx + dy;\n  },\n\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\n  euclidean: function euclidean(dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\n  octile: function octile(dx, dy) {\n    var F = Math.SQRT2 - 1;\n    return dx < dy ? F * dx + dy : F * dy + dx;\n  },\n\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\n  chebyshev: function chebyshev(dx, dy) {\n    return Math.max(dx, dy);\n  }\n};\n\n//# sourceURL=webpack:///./src/core/Heuristic.js?");

/***/ }),

/***/ "./src/core/Node.js":
/*!**************************!*\
  !*** ./src/core/Node.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\nfunction Node(x, y, walkable) {\n  /**\r\n   * The x coordinate of the node on the grid.\r\n   * @type number\r\n   */\n  this.x = x;\n  /**\r\n   * The y coordinate of the node on the grid.\r\n   * @type number\r\n   */\n\n  this.y = y;\n  /**\r\n   * Whether this node can be walked through.\r\n   * @type boolean\r\n   */\n\n  this.walkable = walkable === undefined ? true : walkable;\n}\n\nmodule.exports = Node;\n\n//# sourceURL=webpack:///./src/core/Node.js?");

/***/ }),

/***/ "./src/core/Util.js":
/*!**************************!*\
  !*** ./src/core/Util.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\nfunction backtrace(node) {\n  var path = [[node.x, node.y]];\n\n  while (node.parent) {\n    node = node.parent;\n    path.push([node.x, node.y]);\n  }\n\n  return path.reverse();\n}\n\nexports.backtrace = backtrace;\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\n\nfunction biBacktrace(nodeA, nodeB) {\n  var pathA = backtrace(nodeA),\n      pathB = backtrace(nodeB);\n  return pathA.concat(pathB.reverse());\n}\n\nexports.biBacktrace = biBacktrace;\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\n\nfunction pathLength(path) {\n  var i,\n      sum = 0,\n      a,\n      b,\n      dx,\n      dy;\n\n  for (i = 1; i < path.length; ++i) {\n    a = path[i - 1];\n    b = path[i];\n    dx = a[0] - b[0];\n    dy = a[1] - b[1];\n    sum += Math.sqrt(dx * dx + dy * dy);\n  }\n\n  return sum;\n}\n\nexports.pathLength = pathLength;\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\n\nfunction interpolate(x0, y0, x1, y1) {\n  var abs = Math.abs,\n      line = [],\n      sx,\n      sy,\n      dx,\n      dy,\n      err,\n      e2;\n  dx = abs(x1 - x0);\n  dy = abs(y1 - y0);\n  sx = x0 < x1 ? 1 : -1;\n  sy = y0 < y1 ? 1 : -1;\n  err = dx - dy;\n\n  while (true) {\n    line.push([x0, y0]);\n\n    if (x0 === x1 && y0 === y1) {\n      break;\n    }\n\n    e2 = 2 * err;\n\n    if (e2 > -dy) {\n      err = err - dy;\n      x0 = x0 + sx;\n    }\n\n    if (e2 < dx) {\n      err = err + dx;\n      y0 = y0 + sy;\n    }\n  }\n\n  return line;\n}\n\nexports.interpolate = interpolate;\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\n\nfunction expandPath(path) {\n  var expanded = [],\n      len = path.length,\n      coord0,\n      coord1,\n      interpolated,\n      interpolatedLen,\n      i,\n      j;\n\n  if (len < 2) {\n    return expanded;\n  }\n\n  for (i = 0; i < len - 1; ++i) {\n    coord0 = path[i];\n    coord1 = path[i + 1];\n    interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n    interpolatedLen = interpolated.length;\n\n    for (j = 0; j < interpolatedLen - 1; ++j) {\n      expanded.push(interpolated[j]);\n    }\n  }\n\n  expanded.push(path[len - 1]);\n  return expanded;\n}\n\nexports.expandPath = expandPath;\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\n\nfunction smoothenPath(grid, path) {\n  var len = path.length,\n      x0 = path[0][0],\n      // path start x\n  y0 = path[0][1],\n      // path start y\n  x1 = path[len - 1][0],\n      // path end x\n  y1 = path[len - 1][1],\n      // path end y\n  sx,\n      sy,\n      // current start coordinate\n  ex,\n      ey,\n      // current end coordinate\n  newPath,\n      i,\n      j,\n      coord,\n      line,\n      testCoord,\n      blocked;\n  sx = x0;\n  sy = y0;\n  newPath = [[sx, sy]];\n\n  for (i = 2; i < len; ++i) {\n    coord = path[i];\n    ex = coord[0];\n    ey = coord[1];\n    line = interpolate(sx, sy, ex, ey);\n    blocked = false;\n\n    for (j = 1; j < line.length; ++j) {\n      testCoord = line[j];\n\n      if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n        blocked = true;\n        break;\n      }\n    }\n\n    if (blocked) {\n      lastValidCoord = path[i - 1];\n      newPath.push(lastValidCoord);\n      sx = lastValidCoord[0];\n      sy = lastValidCoord[1];\n    }\n  }\n\n  newPath.push([x1, y1]);\n  return newPath;\n}\n\nexports.smoothenPath = smoothenPath;\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\n\nfunction compressPath(path) {\n  // nothing to compress\n  if (path.length < 3) {\n    return path;\n  }\n\n  var compressed = [],\n      sx = path[0][0],\n      // start x\n  sy = path[0][1],\n      // start y\n  px = path[1][0],\n      // second point x\n  py = path[1][1],\n      // second point y\n  dx = px - sx,\n      // direction between the two points\n  dy = py - sy,\n      // direction between the two points\n  lx,\n      ly,\n      ldx,\n      ldy,\n      sq,\n      i; // normalize the direction\n\n  sq = Math.sqrt(dx * dx + dy * dy);\n  dx /= sq;\n  dy /= sq; // start the new path\n\n  compressed.push([sx, sy]);\n\n  for (i = 2; i < path.length; i++) {\n    // store the last point\n    lx = px;\n    ly = py; // store the last direction\n\n    ldx = dx;\n    ldy = dy; // next point\n\n    px = path[i][0];\n    py = path[i][1]; // next direction\n\n    dx = px - lx;\n    dy = py - ly; // normalize\n\n    sq = Math.sqrt(dx * dx + dy * dy);\n    dx /= sq;\n    dy /= sq; // if the direction has changed, store the point\n\n    if (dx !== ldx || dy !== ldy) {\n      compressed.push([lx, ly]);\n    }\n  } // store the last point\n\n\n  compressed.push([px, py]);\n  return compressed;\n}\n\nexports.compressPath = compressPath;\n\n//# sourceURL=webpack:///./src/core/Util.js?");

/***/ }),

/***/ "./src/finders/AStarFinder.js":
/*!************************************!*\
  !*** ./src/finders/AStarFinder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Heap = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\n\nvar Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar Heuristic = __webpack_require__(/*! ../core/Heuristic */ \"./src/core/Heuristic.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\n\n\nfunction AStarFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.weight = opt.weight || 1;\n  this.diagonalMovement = opt.diagonalMovement;\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  } // When diagonal movement is allowed the manhattan heuristic is not\n  //admissible. It should be octile instead\n\n\n  if (this.diagonalMovement === DiagonalMovement.Never) {\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n  } else {\n    this.heuristic = opt.heuristic || Heuristic.octile;\n  }\n}\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = new Heap(function (nodeA, nodeB) {\n    return nodeA.f - nodeB.f;\n  }),\n      startNode = grid.getNodeAt(startX, startY),\n      endNode = grid.getNodeAt(endX, endY),\n      heuristic = this.heuristic,\n      diagonalMovement = this.diagonalMovement,\n      weight = this.weight,\n      abs = Math.abs,\n      SQRT2 = Math.SQRT2,\n      node,\n      neighbors,\n      neighbor,\n      i,\n      l,\n      x,\n      y,\n      ng; // set the `g` and `f` value of the start node to be 0\n\n  startNode.g = 0;\n  startNode.f = 0; // push the start node into the open list\n\n  openList.push(startNode);\n  startNode.opened = true; // while the open list is not empty\n\n  while (!openList.empty()) {\n    // pop the position of node which has the minimum `f` value.\n    node = openList.pop();\n    node.closed = true; // if reached the end position, construct the path and return it\n\n    if (node === endNode) {\n      return Util.backtrace(endNode);\n    } // get neigbours of the current node\n\n\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      x = neighbor.x;\n      y = neighbor.y; // get the distance between current node and the neighbor\n      // and calculate the next g score\n\n      ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2); // check if the neighbor has not been inspected yet, or\n      // can be reached with smaller cost from the current node\n\n      if (!neighbor.opened || ng < neighbor.g) {\n        neighbor.g = ng;\n        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.parent = node;\n\n        if (!neighbor.opened) {\n          openList.push(neighbor);\n          neighbor.opened = true;\n        } else {\n          // the neighbor can be reached with smaller cost.\n          // Since its f value has been updated, we have to\n          // update its position in the open list\n          openList.updateItem(neighbor);\n        }\n      }\n    } // end for each neighbor\n\n  } // end while not open list empty\n  // fail to find the path\n\n\n  return [];\n};\n\nmodule.exports = AStarFinder;\n\n//# sourceURL=webpack:///./src/finders/AStarFinder.js?");

/***/ }),

/***/ "./src/finders/BestFirstFinder.js":
/*!****************************************!*\
  !*** ./src/finders/BestFirstFinder.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AStarFinder = __webpack_require__(/*! ./AStarFinder */ \"./src/finders/AStarFinder.js\");\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\n\n\nfunction BestFirstFinder(opt) {\n  AStarFinder.call(this, opt);\n  var orig = this.heuristic;\n\n  this.heuristic = function (dx, dy) {\n    return orig(dx, dy) * 1000000;\n  };\n}\n\nBestFirstFinder.prototype = new AStarFinder();\nBestFirstFinder.prototype.constructor = BestFirstFinder;\nmodule.exports = BestFirstFinder;\n\n//# sourceURL=webpack:///./src/finders/BestFirstFinder.js?");

/***/ }),

/***/ "./src/finders/BiAStarFinder.js":
/*!**************************************!*\
  !*** ./src/finders/BiAStarFinder.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Heap = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\n\nvar Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar Heuristic = __webpack_require__(/*! ../core/Heuristic */ \"./src/core/Heuristic.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\n\n\nfunction BiAStarFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.weight = opt.weight || 1;\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  } //When diagonal movement is allowed the manhattan heuristic is not admissible\n  //It should be octile instead\n\n\n  if (this.diagonalMovement === DiagonalMovement.Never) {\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n  } else {\n    this.heuristic = opt.heuristic || Heuristic.octile;\n  }\n}\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nBiAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var cmp = function cmp(nodeA, nodeB) {\n    return nodeA.f - nodeB.f;\n  },\n      startOpenList = new Heap(cmp),\n      endOpenList = new Heap(cmp),\n      startNode = grid.getNodeAt(startX, startY),\n      endNode = grid.getNodeAt(endX, endY),\n      heuristic = this.heuristic,\n      diagonalMovement = this.diagonalMovement,\n      weight = this.weight,\n      abs = Math.abs,\n      SQRT2 = Math.SQRT2,\n      node,\n      neighbors,\n      neighbor,\n      i,\n      l,\n      x,\n      y,\n      ng,\n      BY_START = 1,\n      BY_END = 2; // set the `g` and `f` value of the start node to be 0\n  // and push it into the start open list\n\n\n  startNode.g = 0;\n  startNode.f = 0;\n  startOpenList.push(startNode);\n  startNode.opened = BY_START; // set the `g` and `f` value of the end node to be 0\n  // and push it into the open open list\n\n  endNode.g = 0;\n  endNode.f = 0;\n  endOpenList.push(endNode);\n  endNode.opened = BY_END; // while both the open lists are not empty\n\n  while (!startOpenList.empty() && !endOpenList.empty()) {\n    // pop the position of start node which has the minimum `f` value.\n    node = startOpenList.pop();\n    node.closed = true; // get neigbours of the current node\n\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened === BY_END) {\n        return Util.biBacktrace(node, neighbor);\n      }\n\n      x = neighbor.x;\n      y = neighbor.y; // get the distance between current node and the neighbor\n      // and calculate the next g score\n\n      ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2); // check if the neighbor has not been inspected yet, or\n      // can be reached with smaller cost from the current node\n\n      if (!neighbor.opened || ng < neighbor.g) {\n        neighbor.g = ng;\n        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.parent = node;\n\n        if (!neighbor.opened) {\n          startOpenList.push(neighbor);\n          neighbor.opened = BY_START;\n        } else {\n          // the neighbor can be reached with smaller cost.\n          // Since its f value has been updated, we have to\n          // update its position in the open list\n          startOpenList.updateItem(neighbor);\n        }\n      }\n    } // end for each neighbor\n    // pop the position of end node which has the minimum `f` value.\n\n\n    node = endOpenList.pop();\n    node.closed = true; // get neigbours of the current node\n\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened === BY_START) {\n        return Util.biBacktrace(neighbor, node);\n      }\n\n      x = neighbor.x;\n      y = neighbor.y; // get the distance between current node and the neighbor\n      // and calculate the next g score\n\n      ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2); // check if the neighbor has not been inspected yet, or\n      // can be reached with smaller cost from the current node\n\n      if (!neighbor.opened || ng < neighbor.g) {\n        neighbor.g = ng;\n        neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.parent = node;\n\n        if (!neighbor.opened) {\n          endOpenList.push(neighbor);\n          neighbor.opened = BY_END;\n        } else {\n          // the neighbor can be reached with smaller cost.\n          // Since its f value has been updated, we have to\n          // update its position in the open list\n          endOpenList.updateItem(neighbor);\n        }\n      }\n    } // end for each neighbor\n\n  } // end while not open list empty\n  // fail to find the path\n\n\n  return [];\n};\n\nmodule.exports = BiAStarFinder;\n\n//# sourceURL=webpack:///./src/finders/BiAStarFinder.js?");

/***/ }),

/***/ "./src/finders/BiBestFirstFinder.js":
/*!******************************************!*\
  !*** ./src/finders/BiBestFirstFinder.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var BiAStarFinder = __webpack_require__(/*! ./BiAStarFinder */ \"./src/finders/BiAStarFinder.js\");\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\n\n\nfunction BiBestFirstFinder(opt) {\n  BiAStarFinder.call(this, opt);\n  var orig = this.heuristic;\n\n  this.heuristic = function (dx, dy) {\n    return orig(dx, dy) * 1000000;\n  };\n}\n\nBiBestFirstFinder.prototype = new BiAStarFinder();\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\nmodule.exports = BiBestFirstFinder;\n\n//# sourceURL=webpack:///./src/finders/BiBestFirstFinder.js?");

/***/ }),

/***/ "./src/finders/BiBreadthFirstFinder.js":
/*!*********************************************!*\
  !*** ./src/finders/BiBreadthFirstFinder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\n\n\nfunction BiBreadthFirstFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  }\n}\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nBiBreadthFirstFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var startNode = grid.getNodeAt(startX, startY),\n      endNode = grid.getNodeAt(endX, endY),\n      startOpenList = [],\n      endOpenList = [],\n      neighbors,\n      neighbor,\n      node,\n      diagonalMovement = this.diagonalMovement,\n      BY_START = 0,\n      BY_END = 1,\n      i,\n      l; // push the start and end nodes into the queues\n\n  startOpenList.push(startNode);\n  startNode.opened = true;\n  startNode.by = BY_START;\n  endOpenList.push(endNode);\n  endNode.opened = true;\n  endNode.by = BY_END; // while both the queues are not empty\n\n  while (startOpenList.length && endOpenList.length) {\n    // expand start open list\n    node = startOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened) {\n        // if this node has been inspected by the reversed search,\n        // then a path is found.\n        if (neighbor.by === BY_END) {\n          return Util.biBacktrace(node, neighbor);\n        }\n\n        continue;\n      }\n\n      startOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_START;\n    } // expand end open list\n\n\n    node = endOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened) {\n        if (neighbor.by === BY_START) {\n          return Util.biBacktrace(neighbor, node);\n        }\n\n        continue;\n      }\n\n      endOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_END;\n    }\n  } // fail to find the path\n\n\n  return [];\n};\n\nmodule.exports = BiBreadthFirstFinder;\n\n//# sourceURL=webpack:///./src/finders/BiBreadthFirstFinder.js?");

/***/ }),

/***/ "./src/finders/BiDijkstraFinder.js":
/*!*****************************************!*\
  !*** ./src/finders/BiDijkstraFinder.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var BiAStarFinder = __webpack_require__(/*! ./BiAStarFinder */ \"./src/finders/BiAStarFinder.js\");\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\n\n\nfunction BiDijkstraFinder(opt) {\n  BiAStarFinder.call(this, opt);\n\n  this.heuristic = function (dx, dy) {\n    return 0;\n  };\n}\n\nBiDijkstraFinder.prototype = new BiAStarFinder();\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\nmodule.exports = BiDijkstraFinder;\n\n//# sourceURL=webpack:///./src/finders/BiDijkstraFinder.js?");

/***/ }),

/***/ "./src/finders/BreadthFirstFinder.js":
/*!*******************************************!*\
  !*** ./src/finders/BreadthFirstFinder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\n\n\nfunction BreadthFirstFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  }\n}\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nBreadthFirstFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = [],\n      diagonalMovement = this.diagonalMovement,\n      startNode = grid.getNodeAt(startX, startY),\n      endNode = grid.getNodeAt(endX, endY),\n      neighbors,\n      neighbor,\n      node,\n      i,\n      l; // push the start pos into the queue\n\n  openList.push(startNode);\n  startNode.opened = true; // while the queue is not empty\n\n  while (openList.length) {\n    // take the front node from the queue\n    node = openList.shift();\n    node.closed = true; // reached the end position\n\n    if (node === endNode) {\n      return Util.backtrace(endNode);\n    }\n\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i]; // skip this neighbor if it has been inspected before\n\n      if (neighbor.closed || neighbor.opened) {\n        continue;\n      }\n\n      openList.push(neighbor);\n      neighbor.opened = true;\n      neighbor.parent = node;\n    }\n  } // fail to find the path\n\n\n  return [];\n};\n\nmodule.exports = BreadthFirstFinder;\n\n//# sourceURL=webpack:///./src/finders/BreadthFirstFinder.js?");

/***/ }),

/***/ "./src/finders/DijkstraFinder.js":
/*!***************************************!*\
  !*** ./src/finders/DijkstraFinder.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AStarFinder = __webpack_require__(/*! ./AStarFinder */ \"./src/finders/AStarFinder.js\");\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\n\n\nfunction DijkstraFinder(opt) {\n  AStarFinder.call(this, opt);\n\n  this.heuristic = function (dx, dy) {\n    return 0;\n  };\n}\n\nDijkstraFinder.prototype = new AStarFinder();\nDijkstraFinder.prototype.constructor = DijkstraFinder;\nmodule.exports = DijkstraFinder;\n\n//# sourceURL=webpack:///./src/finders/DijkstraFinder.js?");

/***/ }),

/***/ "./src/finders/IDAStarFinder.js":
/*!**************************************!*\
  !*** ./src/finders/IDAStarFinder.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar Heuristic = __webpack_require__(/*! ../core/Heuristic */ \"./src/core/Heuristic.js\");\n\nvar Node = __webpack_require__(/*! ../core/Node */ \"./src/core/Node.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\n\n\nfunction IDAStarFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.weight = opt.weight || 1;\n  this.trackRecursion = opt.trackRecursion || false;\n  this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  } // When diagonal movement is allowed the manhattan heuristic is not\n  // admissible, it should be octile instead\n\n\n  if (this.diagonalMovement === DiagonalMovement.Never) {\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n  } else {\n    this.heuristic = opt.heuristic || Heuristic.octile;\n  }\n}\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nIDAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  // Used for statistics:\n  var nodesVisited = 0; // Execution time limitation:\n\n  var startTime = new Date().getTime(); // Heuristic helper:\n\n  var h = function (a, b) {\n    return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n  }.bind(this); // Step cost from a to b:\n\n\n  var cost = function cost(a, b) {\n    return a.x === b.x || a.y === b.y ? 1 : Math.SQRT2;\n  };\n  /**\r\n   * IDA* search implementation.\r\n   *\r\n   * @param {Node} The node currently expanding from.\r\n   * @param {number} Cost to reach the given node.\r\n   * @param {number} Maximum search depth (cut-off value).\r\n   * @param {Array<Array<number>>} The found route.\r\n   * @param {number} Recursion depth.\r\n   *\r\n   * @return {Object} either a number with the new optimal cut-off depth,\r\n   * or a valid node instance, in which case a path was found.\r\n   */\n\n\n  var search = function (node, g, cutoff, route, depth) {\n    nodesVisited++; // Enforce timelimit:\n\n    if (this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {\n      // Enforced as \"path-not-found\".\n      return Infinity;\n    }\n\n    var f = g + h(node, end) * this.weight; // We've searched too deep for this iteration.\n\n    if (f > cutoff) {\n      return f;\n    }\n\n    if (node == end) {\n      route[depth] = [node.x, node.y];\n      return node;\n    }\n\n    var min, t, k, neighbour;\n    var neighbours = grid.getNeighbors(node, this.diagonalMovement); // Sort the neighbours, gives nicer paths. But, this deviates\n    // from the original algorithm - so I left it out.\n    //neighbours.sort(function(a, b){\n    //    return h(a, end) - h(b, end);\n    //});\n\n    /*jshint -W084 */\n    //Disable warning: Expected a conditional expression and instead saw an assignment\n\n    for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n      /*jshint +W084 */\n      //Enable warning: Expected a conditional expression and instead saw an assignment\n      if (this.trackRecursion) {\n        // Retain a copy for visualisation. Due to recursion, this\n        // node may be part of other paths too.\n        neighbour.retainCount = neighbour.retainCount + 1 || 1;\n\n        if (neighbour.tested !== true) {\n          neighbour.tested = true;\n        }\n      }\n\n      t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n\n      if (t instanceof Node) {\n        route[depth] = [node.x, node.y]; // For a typical A* linked list, this would work:\n        // neighbour.parent = node;\n\n        return t;\n      } // Decrement count, then determine whether it's actually closed.\n\n\n      if (this.trackRecursion && --neighbour.retainCount === 0) {\n        neighbour.tested = false;\n      }\n\n      if (t < min) {\n        min = t;\n      }\n    }\n\n    return min;\n  }.bind(this); // Node instance lookups:\n\n\n  var start = grid.getNodeAt(startX, startY);\n  var end = grid.getNodeAt(endX, endY); // Initial search depth, given the typical heuristic contraints,\n  // there should be no cheaper route possible.\n\n  var cutOff = h(start, end);\n  var j, route, t; // With an overflow protection.\n\n  for (j = 0; true; ++j) {\n    route = []; // Search till cut-off depth:\n\n    t = search(start, 0, cutOff, route, 0); // Route not possible, or not found in time limit.\n\n    if (t === Infinity) {\n      return [];\n    } // If t is a node, it's also the end node. Route is now\n    // populated with a valid path to the end node.\n\n\n    if (t instanceof Node) {\n      return route;\n    } // Try again, this time with a deeper cut-off. The t score\n    // is the closest we got to the end node.\n\n\n    cutOff = t;\n  } // This _should_ never to be reached.\n\n\n  return [];\n};\n\nmodule.exports = IDAStarFinder;\n\n//# sourceURL=webpack:///./src/finders/IDAStarFinder.js?");

/***/ }),

/***/ "./src/finders/JPFAlwaysMoveDiagonally.js":
/*!************************************************!*\
  !*** ./src/finders/JPFAlwaysMoveDiagonally.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./src/finders/JumpPointFinderBase.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\n\n\nfunction JPFAlwaysMoveDiagonally(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFAlwaysMoveDiagonally.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  } // check for forced neighbors\n  // along the diagonal\n\n\n  if (dx !== 0 && dy !== 0) {\n    if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {\n      return [x, y];\n    } // when moving diagonally, must check for vertical/horizontal jump points\n\n\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  } // horizontally/vertically\n  else {\n      if (dx !== 0) {\n        // moving along x\n        if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {\n          return [x, y];\n        }\n      } else {\n        if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {\n          return [x, y];\n        }\n      }\n    }\n\n  return this._jump(x + dx, y + dy, x, y);\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1); // search diagonally\n\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y + dy)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x - dx, y)) {\n        neighbors.push([x - dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x, y - dy)) {\n        neighbors.push([x + dx, y - dy]);\n      }\n    } // search horizontally/vertically\n    else {\n        if (dx === 0) {\n          if (grid.isWalkableAt(x, y + dy)) {\n            neighbors.push([x, y + dy]);\n          }\n\n          if (!grid.isWalkableAt(x + 1, y)) {\n            neighbors.push([x + 1, y + dy]);\n          }\n\n          if (!grid.isWalkableAt(x - 1, y)) {\n            neighbors.push([x - 1, y + dy]);\n          }\n        } else {\n          if (grid.isWalkableAt(x + dx, y)) {\n            neighbors.push([x + dx, y]);\n          }\n\n          if (!grid.isWalkableAt(x, y + 1)) {\n            neighbors.push([x + dx, y + 1]);\n          }\n\n          if (!grid.isWalkableAt(x, y - 1)) {\n            neighbors.push([x + dx, y - 1]);\n          }\n        }\n      }\n  } // return all neighbors\n  else {\n      neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\n\n      for (i = 0, l = neighborNodes.length; i < l; ++i) {\n        neighborNode = neighborNodes[i];\n        neighbors.push([neighborNode.x, neighborNode.y]);\n      }\n    }\n\n  return neighbors;\n};\n\nmodule.exports = JPFAlwaysMoveDiagonally;\n\n//# sourceURL=webpack:///./src/finders/JPFAlwaysMoveDiagonally.js?");

/***/ }),

/***/ "./src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js":
/*!*************************************************************!*\
  !*** ./src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./src/finders/JumpPointFinderBase.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\n\n\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  } // check for forced neighbors\n  // along the diagonal\n\n\n  if (dx !== 0 && dy !== 0) {\n    if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {\n      return [x, y];\n    } // when moving diagonally, must check for vertical/horizontal jump points\n\n\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  } // horizontally/vertically\n  else {\n      if (dx !== 0) {\n        // moving along x\n        if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {\n          return [x, y];\n        }\n      } else {\n        if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {\n          return [x, y];\n        }\n      }\n    } // moving diagonally, must make sure one of the vertical/horizontal\n  // neighbors is open to allow the path\n\n\n  if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\n    return this._jump(x + dx, y + dy, x, y);\n  } else {\n    return null;\n  }\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1); // search diagonally\n\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x - dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y - dy]);\n      }\n    } // search horizontally/vertically\n    else {\n        if (dx === 0) {\n          if (grid.isWalkableAt(x, y + dy)) {\n            neighbors.push([x, y + dy]);\n\n            if (!grid.isWalkableAt(x + 1, y)) {\n              neighbors.push([x + 1, y + dy]);\n            }\n\n            if (!grid.isWalkableAt(x - 1, y)) {\n              neighbors.push([x - 1, y + dy]);\n            }\n          }\n        } else {\n          if (grid.isWalkableAt(x + dx, y)) {\n            neighbors.push([x + dx, y]);\n\n            if (!grid.isWalkableAt(x, y + 1)) {\n              neighbors.push([x + dx, y + 1]);\n            }\n\n            if (!grid.isWalkableAt(x, y - 1)) {\n              neighbors.push([x + dx, y - 1]);\n            }\n          }\n        }\n      }\n  } // return all neighbors\n  else {\n      neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\n\n      for (i = 0, l = neighborNodes.length; i < l; ++i) {\n        neighborNode = neighborNodes[i];\n        neighbors.push([neighborNode.x, neighborNode.y]);\n      }\n    }\n\n  return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\n\n//# sourceURL=webpack:///./src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js?");

/***/ }),

/***/ "./src/finders/JPFMoveDiagonallyIfNoObstacles.js":
/*!*******************************************************!*\
  !*** ./src/finders/JPFMoveDiagonallyIfNoObstacles.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./src/finders/JumpPointFinderBase.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\n\n\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  } // check for forced neighbors\n  // along the diagonal\n\n\n  if (dx !== 0 && dy !== 0) {\n    // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n    // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n    // return [x, y];\n    // }\n    // when moving diagonally, must check for vertical/horizontal jump points\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  } // horizontally/vertically\n  else {\n      if (dx !== 0) {\n        if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {\n          return [x, y];\n        }\n      } else if (dy !== 0) {\n        if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {\n          return [x, y];\n        } // When moving vertically, must check for horizontal jump points\n        // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n        // return [x, y];\n        // }\n\n      }\n    } // moving diagonally, must make sure one of the vertical/horizontal\n  // neighbors is open to allow the path\n\n\n  if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\n    return this._jump(x + dx, y + dy, x, y);\n  } else {\n    return null;\n  }\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1); // search diagonally\n\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n    } // search horizontally/vertically\n    else {\n        var isNextWalkable;\n\n        if (dx !== 0) {\n          isNextWalkable = grid.isWalkableAt(x + dx, y);\n          var isTopWalkable = grid.isWalkableAt(x, y + 1);\n          var isBottomWalkable = grid.isWalkableAt(x, y - 1);\n\n          if (isNextWalkable) {\n            neighbors.push([x + dx, y]);\n\n            if (isTopWalkable) {\n              neighbors.push([x + dx, y + 1]);\n            }\n\n            if (isBottomWalkable) {\n              neighbors.push([x + dx, y - 1]);\n            }\n          }\n\n          if (isTopWalkable) {\n            neighbors.push([x, y + 1]);\n          }\n\n          if (isBottomWalkable) {\n            neighbors.push([x, y - 1]);\n          }\n        } else if (dy !== 0) {\n          isNextWalkable = grid.isWalkableAt(x, y + dy);\n          var isRightWalkable = grid.isWalkableAt(x + 1, y);\n          var isLeftWalkable = grid.isWalkableAt(x - 1, y);\n\n          if (isNextWalkable) {\n            neighbors.push([x, y + dy]);\n\n            if (isRightWalkable) {\n              neighbors.push([x + 1, y + dy]);\n            }\n\n            if (isLeftWalkable) {\n              neighbors.push([x - 1, y + dy]);\n            }\n          }\n\n          if (isRightWalkable) {\n            neighbors.push([x + 1, y]);\n          }\n\n          if (isLeftWalkable) {\n            neighbors.push([x - 1, y]);\n          }\n        }\n      }\n  } // return all neighbors\n  else {\n      neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\n\n      for (i = 0, l = neighborNodes.length; i < l; ++i) {\n        neighborNode = neighborNodes[i];\n        neighbors.push([neighborNode.x, neighborNode.y]);\n      }\n    }\n\n  return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\n\n//# sourceURL=webpack:///./src/finders/JPFMoveDiagonallyIfNoObstacles.js?");

/***/ }),

/***/ "./src/finders/JPFNeverMoveDiagonally.js":
/*!***********************************************!*\
  !*** ./src/finders/JPFNeverMoveDiagonally.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./src/finders/JumpPointFinderBase.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\n\n\nfunction JPFNeverMoveDiagonally(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFNeverMoveDiagonally.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  }\n\n  if (dx !== 0) {\n    if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {\n      return [x, y];\n    }\n  } else if (dy !== 0) {\n    if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {\n      return [x, y];\n    } //When moving vertically, must check for horizontal jump points\n\n\n    if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n      return [x, y];\n    }\n  } else {\n    throw new Error(\"Only horizontal and vertical movements are allowed\");\n  }\n\n  return this._jump(x + dx, y + dy, x, y);\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFNeverMoveDiagonally.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n    if (dx !== 0) {\n      if (grid.isWalkableAt(x, y - 1)) {\n        neighbors.push([x, y - 1]);\n      }\n\n      if (grid.isWalkableAt(x, y + 1)) {\n        neighbors.push([x, y + 1]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n    } else if (dy !== 0) {\n      if (grid.isWalkableAt(x - 1, y)) {\n        neighbors.push([x - 1, y]);\n      }\n\n      if (grid.isWalkableAt(x + 1, y)) {\n        neighbors.push([x + 1, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n    }\n  } // return all neighbors\n  else {\n      neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n\n      for (i = 0, l = neighborNodes.length; i < l; ++i) {\n        neighborNode = neighborNodes[i];\n        neighbors.push([neighborNode.x, neighborNode.y]);\n      }\n    }\n\n  return neighbors;\n};\n\nmodule.exports = JPFNeverMoveDiagonally;\n\n//# sourceURL=webpack:///./src/finders/JPFNeverMoveDiagonally.js?");

/***/ }),

/***/ "./src/finders/JumpPointFinder.js":
/*!****************************************!*\
  !*** ./src/finders/JumpPointFinder.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author aniero / https://github.com/aniero\r\n */\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n\nvar JPFNeverMoveDiagonally = __webpack_require__(/*! ./JPFNeverMoveDiagonally */ \"./src/finders/JPFNeverMoveDiagonally.js\");\n\nvar JPFAlwaysMoveDiagonally = __webpack_require__(/*! ./JPFAlwaysMoveDiagonally */ \"./src/finders/JPFAlwaysMoveDiagonally.js\");\n\nvar JPFMoveDiagonallyIfNoObstacles = __webpack_require__(/*! ./JPFMoveDiagonallyIfNoObstacles */ \"./src/finders/JPFMoveDiagonallyIfNoObstacles.js\");\n\nvar JPFMoveDiagonallyIfAtMostOneObstacle = __webpack_require__(/*! ./JPFMoveDiagonallyIfAtMostOneObstacle */ \"./src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js\");\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\n\n\nfunction JumpPointFinder(opt) {\n  opt = opt || {};\n\n  if (opt.diagonalMovement === DiagonalMovement.Never) {\n    return new JPFNeverMoveDiagonally(opt);\n  } else if (opt.diagonalMovement === DiagonalMovement.Always) {\n    return new JPFAlwaysMoveDiagonally(opt);\n  } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n    return new JPFMoveDiagonallyIfNoObstacles(opt);\n  } else {\n    return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\n  }\n}\n\nmodule.exports = JumpPointFinder;\n\n//# sourceURL=webpack:///./src/finders/JumpPointFinder.js?");

/***/ }),

/***/ "./src/finders/JumpPointFinderBase.js":
/*!********************************************!*\
  !*** ./src/finders/JumpPointFinderBase.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * @author imor / https://github.com/imor\r\n */\nvar Heap = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\n\nvar Util = __webpack_require__(/*! ../core/Util */ \"./src/core/Util.js\");\n\nvar Heuristic = __webpack_require__(/*! ../core/Heuristic */ \"./src/core/Heuristic.js\");\n\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./src/core/DiagonalMovement.js\");\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\n\n\nfunction JumpPointFinderBase(opt) {\n  opt = opt || {};\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nJumpPointFinderBase.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = this.openList = new Heap(function (nodeA, nodeB) {\n    return nodeA.f - nodeB.f;\n  }),\n      startNode = this.startNode = grid.getNodeAt(startX, startY),\n      endNode = this.endNode = grid.getNodeAt(endX, endY),\n      node;\n  this.grid = grid; // set the `g` and `f` value of the start node to be 0\n\n  startNode.g = 0;\n  startNode.f = 0; // push the start node into the open list\n\n  openList.push(startNode);\n  startNode.opened = true; // while the open list is not empty\n\n  while (!openList.empty()) {\n    // pop the position of node which has the minimum `f` value.\n    node = openList.pop();\n    node.closed = true;\n\n    if (node === endNode) {\n      return Util.expandPath(Util.backtrace(endNode));\n    }\n\n    this._identifySuccessors(node);\n  } // fail to find the path\n\n\n  return [];\n};\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\n\n\nJumpPointFinderBase.prototype._identifySuccessors = function (node) {\n  var grid = this.grid,\n      heuristic = this.heuristic,\n      openList = this.openList,\n      endX = this.endNode.x,\n      endY = this.endNode.y,\n      neighbors,\n      neighbor,\n      jumpPoint,\n      i,\n      l,\n      x = node.x,\n      y = node.y,\n      jx,\n      jy,\n      dx,\n      dy,\n      d,\n      ng,\n      jumpNode,\n      abs = Math.abs,\n      max = Math.max;\n  neighbors = this._findNeighbors(node);\n\n  for (i = 0, l = neighbors.length; i < l; ++i) {\n    neighbor = neighbors[i];\n    jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n\n    if (jumpPoint) {\n      jx = jumpPoint[0];\n      jy = jumpPoint[1];\n      jumpNode = grid.getNodeAt(jx, jy);\n\n      if (jumpNode.closed) {\n        continue;\n      } // include distance, as parent may not be immediately adjacent:\n\n\n      d = Heuristic.octile(abs(jx - x), abs(jy - y));\n      ng = node.g + d; // next `g` value\n\n      if (!jumpNode.opened || ng < jumpNode.g) {\n        jumpNode.g = ng;\n        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n        jumpNode.f = jumpNode.g + jumpNode.h;\n        jumpNode.parent = node;\n\n        if (!jumpNode.opened) {\n          openList.push(jumpNode);\n          jumpNode.opened = true;\n        } else {\n          openList.updateItem(jumpNode);\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = JumpPointFinderBase;\n\n//# sourceURL=webpack:///./src/finders/JumpPointFinderBase.js?");

/***/ })

/******/ });